# JavaSE

<BR>

## 第一部分：基础知识

<BR>

<BR>

<BR>

<BR>

## 第二部分：面向对象

<BR>

### 1.封装

#### 类

- 对一类事物抽象所得到的的一个概念

#### 对象

- 一个具体的事物

#### 构造函数

- 不能有返回值、方法名与类名相同
- 可以有多个。生成一个对象时只能调用其中一个构造函数。
- 默认生成无参，无方法体，无返回值的构造函数。但一旦自己定义，编译器将不再生成默认的构造函数。

#### static

- 凡是static修饰的成员都是静态成员。静态成员都是属于类的。
- 非静态的可以访问静态的。静态的而不可以访问非静态的
- 通过类名只能访问一个类中的非私有的静态成员。私有静态成员也不可以通过对象吗访问。

#### this

- 非静态方法默认都含有一个this指针。this代表正在调用本方法的对象。

#### final

- 修饰类：则该类不能被继承。修饰方法：则该方法可以被继承但不能被重写。修饰属性：表示该属性能且只能被赋一次值，赋值方式有两种，并且只能选择其中一种：1.定义的同时，显式初始化。2.在构造函数中初始化。

#### 函数重载

- 同名不同参。返回值不能作为是否构成函数重载的依据。

<BR>

### 2.继承

#### 定义

- 子类继承了父类的成员

#### 注意：

- 非私有成员才可以被子类继承
- 重写：
  - 重写方法必须和被重写方法具有相同的方法名称，参数列表，返回值类型。
  - 重写方法的访问权限不能小于被重写方法
- 构造器：
  - 继承后的构造器，里面默认有super()来调用父类构造方法。但写了this()构造器后则super()失效。
  - 子类永远无法继承父类的构造方法。因此，要在子类的构造方法中使用语句super(参数列表)调用父类的构造方法。（已经继承了父类的属性，需要初始化他们）（也可以全部用this.name = name，但父类属性很多时这样写会很繁琐；且父类属性私有时，访问不了，但用super构造方法可以）
  - 普通方法中不能调用父类的构造方法（super（））
  - 必须是构造方法的第一条语句
  - 不写super，则默认调用super（）

<BR>

### 3.多态

#### 定义

- 同一代码可以随上下文的不同而执行不同的操作，俗称多态
- 即：
  - 一个父类的引用它既可以指向父类对象也可以指向子类对象
  - 他可以根据当前时刻指向的不同，自动调用不用对象的方法
- 多态的前提是两个对象（类）之间存在继承关系

#### 编译类型和运行类型

- 编译类型看对象定义时等号的左边，运行类型看右边

- 编译类型在定义对象时就确定了，不能改变

- 运行类型是可以变化的

- ```java
  Animal animal = new Dog();
  animal = new Cat();//运行类型变了，编译类型没变，仍是Animal
  ```

#### 多态的向上转型

- 本质：父类的引用指向了子类的对象
- 语法：父类类型 引用名 = new 子类类型();
- 特点：
  - 编译类型看左边，运行类型看右边
  - 可以调用父类中的所有成员（遵循访问权限），最终运行效果看子类的具体实现
  - 不能调用子类中的特有成员（因为在编译阶段看的是编译类型，所有这样做时直接会出错）

#### 多态的向下转型

- 语法： 子类类型 引用名 = （子类类型） 父类引用;
- 只能强转父类的引用，不能强转父类的对象
- 要求父类的引用必须指向的是当前目标类型的对象
- 当向下转型后，可以调用子类类型中的所有成员

#### 注意事项

- 属性没有重写的说法。属性的值看编译类型是什么。
- aa instanceOf AA。可以用于判断对象的运行类型是否为XX类型或XX类型的子类型
- 通过父类的引用，只能访问子类从父类继承过来的成员
- 只有在父类的引用本身指向的就是一个子类对象上，我们才可以把父类的引用强制转化为子类的引用

#### java的动态绑定机制

（非常非常重要）

- 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
- 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

#### 多态的应用

- 多态数组
- 多态参数

<BR>

### 相关知识

#### Object类

- equals和==:

  - ==：
    - ==是比较运算符
      1. 既可以判断基本类型，又可以判断引用类型
      2. 如判断基本类型，则判断值是否相等
      3. 如判断引用类型，则判断地址是否相等

  - equals:
    - equals是Object类中的方法，只能判断引用类型
    - 默认判断的是地址是否相等。
    - 子类往往重写该方法，用于判断内容是否相等。（如Integer，String）

- hashCode()

- toString()

- finalize()

  - 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作 
  - 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法(程序员就可以在里面写自己的业务逻辑代码，比如释放资源：数据库连接、打开的文件......)。如果不重写finalize，那么就会调用Object类的finalize，即默认处理。
  - 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制。提示： 我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试.

#### 抽象类

- 一个抽象类通常都含有抽象方法
- 只重写了抽象类部分抽象方法的类也必须得被标记为abstract
- 不可以定义抽象类对象，但是抽象类可以实现多态

#### 接口

- 接口中的方法都是public abstract
- 不可以定义接口对象，但接口却可以实现多态
- 重写接口方法时public不能省
- 举例：
  - 线程的创建
  - 事件的处理
  - 容器的组织方式
  - serializable接口

<br>

<br>

## 第三部分：高级部分

### 1.异常

#### 定义

- 运行时的错误

#### 分类

- 无法处理的错误
- 可以处理的异常
  - 必须处理的异常
    - 是Exception子类但不是RuntimeException的子类
  - 可处理可不处理的异常
    - 是RuntimeException的子类
- 注意问题：
  - finally{....}一定会执行
  - 先捕获子类异常，再捕获父类异常，顺序不可颠倒
  - 重写方法抛出的异常的范围不能大于倍重写方法抛出的异常的范围
  - 假设f方法抛出了A异常，则f方法有两种方式处理A异常：
    1. throws A
    2. try{ ... } catch( ){ ... }

<br>

### 2.线程

#### 定义

- 一个程序运行时的不同执行路径

#### 创建线程的方式：

- 继承Thread类
- 实现Runnable接口

#### 线程的同步

- 多个线程操作同一资源，并且要求这些操作中的若干个操作不能被中断，这时就需要考虑线程同步的问题
- 线程同步是通过synchronized来实现的
- synchronized可以修饰两种：
  - 代码块
  - 方法（默认锁定的是this）
- 示例：
  - 卖票

#### 线程的通信

- 有时多个线程只有彼此相互协作才可以完成某个功能，这时就需要线程的通信
- 实现方式
  - wait 和 notify()/notifyAll()
- 示例
  - 生产和消费

<br>

### 3.包

#### 包的生成与运行

- package 语句必须是第一条语句。类名是报名和类名的组合。只有在整个包的最上层目录才可以运行

#### 同包，不同包的相互访问

#### jar包的生成与jar包的使用

- 普通jar包的生成
- 可运行jar包的生成

<br>

### 4.GUI

#### 内部类

- 在一个类内部定义的类叫内部类
- 内部类的方法可以访问外部类的所有成员
- 外部类的方法不可以直接访问内部类的任何成员
- 产生内部类的原因：
  - 如果一个类A要使用B类的所有成员，并且A类不需要被除B以外的其他类访问，则我们可以把A定义成B的内部类
  - 几乎不存在直接生成内部类对象的问题，因此几乎不存在外部类需要访问内部类成员的问题

#### 匿名类

- 匿名类是内部类的一种极端表现形式
- 匿名类可以访问外部类的所有成员和包裹本匿名类方法中的final类型的局部变量

<br>

<br>

### 5.IO

#### 定义

- 如果一个类是用来完成程序和设备之间的数据传输，则这个类有一个特殊的称为叫做流。
- 流一定是类，但类不一定是流
- 分类：
  - 输入流  输出流
  - 字节流  字符流
  - 原始流  包裹流

#### 四大基本抽象流

- InputStream OutputStream  <br>

  Reader Writer

- 字节流和字符流的区别：
  - 字节流可以处理所有格式的文件
  - 字符流只能处理文本格式的文件

#### 文件流

- FileInputStream  FileOutputStream

  FileReader  FIleWriter

#### 缓冲流

- BufferedInputStream  BufferedOutputStream

  BufferedReader  BufferedWriter

- 缓冲流可以提高数据传输的速度

#### 转化流

- OutputStreamWriter  InputStreamReader
- 例子：
  - 编程实现：把用户从键盘输入的字符保存到一个String对象中

#### 数据流

- DataInputStream   DataOutputStream
- 数据流可以把基本类型数据的二进制直接读入或写出
- 例子：
  - 编程实现：将long类型数据写入byte数组，然后再从byte数组中把该数据读出

#### Print流

- PrintStream  PrintWriter
- Print流可以把基本类型数据格式化后的字符串输出
- 例子:
  - 编程实现：把键盘输入的数据写入A文件，如果输入有误则把出错信息写入B文件

#### Object流

- ObjectInputStream  ObjectOutputStream
- Object流可以把一个对象直接写入或读出

<br>

### 6.容器

#### 定义

- 如果一个类是专门用来存放其他类对象的，则这个类有另外一个特殊的名字叫容器

- 容器一定是类，但类不一定是容器

#### Collection接口

##### Set 接口

- 无序，不允许重复
- 实现类：
  - TreeSet  HashSet

##### List 接口

- 有序，允许重复
- 实现类：
  - ArrayList  LinkedList

##### Map 接口

- 既保存数据本身，也保存数据的主键的一种接口
- 实现类：HashMap  TreeMap

##### hashCode( )和equals()方法

- 所有hash开头的都用要重写两个方法

#### Collections类

- 该类提供了对Collection接口实现类的排序，倒置、查找等功能

#### Comparable 接口

- 通过该接口的方法可以制定出对象之间比较的标准
- 凡是需要进行对象的比较排序的场合均可以考虑实现该接口

#### Iterator 接口

- 利用该接口提供的方法我们可以遍历所以容器中的元素

